function [xout,e,Kalman,Q2out, Q1out] = mvaar(y,p,UC,mode,Kalman,verb,downsampleFactor,constraints)
% Multivariate (Vector) adaptive AR estimation base on a multidimensional
% Kalman filer algorithm. A standard VAR model (A0=I) is implemented. The
% state vector is defined as X=(A1|A2...|Ap)' and x=vec(X)
%
% [x,e,Kalman,Q2] = mvaar(y,p,UC,mode,Kalman)
%
% The standard MVAR model is defined as:
%
%		y(n)-A1(n)*y(n-1)-...-Ap(n)*y(n-p)=e(n)
%
%	The dimension of y(n) equals s
%
%	Input Parameters:
%
% 		y			Observed data or signal [npnts x nchs]
% 		p			prescribed maximum model order (default 1)
%		UC			update coefficient	(default 0.001)
%		mode	 	update method of the process noise covariance matrix 0...7 ^
%					correspond to S0...S7 (default 0)
%       verb        verbosity
%       constraints structure with fields .D and .d containing constraints
%                   of the form Dx = d
%
%	Output Parameters
%
%		e			prediction error of dimension s
%		x			state vector of dimension s*s*p
%		Q2			measurement noise covariance matrix of dimension s x s
%       Q1          state noise covariance matrix
%

%       $Id: mvaar.m 5090 2008-06-05 08:12:04Z schloegl $
%       Copyright (C) 2001-2002 Christian Kasess
%       Copyright (C) 2003, 2008 Alois Schloegl
%
%       Copyright (C) 2010-2011 Tim Mullen
%
%       Modified by Tim Mullen
%       01/23/2011 -- Modified for downsampled storage 
%       04/13/2011 -- Optimized performance
%       05/12/2011 -- Added projection onto constraint surface [1]
%       
%       [1] Simon D (2010) Kalman Filtering with State Constraints: 
%       A Survey of Linear and Nonlinear Algorithms. 
%       Control Theory & Applications, IET 4:1303-€“1318
%
%    This program is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program.  If not, see <http://www.gnu.org/licenses/>.

if nargin<6
    verb = 2;
end
if nargin<4,
    mode=0;
end;
if nargin<3,
    UC=0.001;
end;
if nargin<2,
    p=1;
end
if nargin<1,
    fprintf(2,'No arguments supplied\n');
    return
end;
if nargin<8 || isempty(constraints)
    doConstraints = 0;
else
    doConstraints = 1;
    Constr_D = constraints.D;
    Constr_d = constraints.d;
end

if ~any(mode==(0:7))
    fprintf(2,'Invalid mode (0...7)\n');
    return
end;


[LEN, M] = size(y);		%number of channels, total signal length
L = M*M*p;

if LEN<(p+1),
    fprintf(2,'Not enough observed data supplied for given model order\n');
    return
end

% ye = zeros(size(y));	%prediction of y

if nargout>1,
    xout=zeros(L,floor(LEN/downsampleFactor));
end;
if nargout>3,
    Q2out=zeros(M,M,floor(LEN/downsampleFactor));
end
if nargout>4,
    Q1out = zeros(M,M,floor(LEN/downsampleFactor));
end;       
if nargout>5
    Kout = zeros(M,M,floor(LEN/downsampleFactor));
end

if verb==2
    h=waitbar(0,sprintf('fitting VAR[%d] model [mode=%s] ...', ...
              p, 'Kalman')); 
end

if nargin<5 || isempty(Kalman)
    %Kalman Filter initialsiation (Kp (K predicted or a-priori) equals K(n+1,n) )
    F   = eye(L);          % observation matrix
    G   = zeros(L,M);      % Kalman Gain
    x   = zeros(L,1);      % state vector
    Kp  = eye(L);        
    Q1  = eye(L);      % state noise covariance matrix
    Q2  = eye(M);         % measurement noise covariance matrix
    ye  = zeros(size(y)); % prediction of y
    
%     Kalman=struct('F',eye(L),'H',zeros(M,L),'G',zeros(L,M),'x',zeros(L,1),'Kp',eye(L),'Q1',eye(L)*UC,'Q2',eye(M),'ye',zeros(size(y)));
else
    ye = Kalman.ye;
    F  = Kalman.F;
    Q1 = Kalman.Q1;
    Kp = Kalman.Kp;
    Q2 = Kalman.Q2;
    x  = Kalman.x;
    H  = Kalman.H;
    G  = Kalman.G;
end

upd = eye(L)/L*UC;		%diagonal matrix containing UC

if(mode==3)
    Block=kron(eye(M),ones(M*p));
elseif(mode==4)
    index=[];
    Block1=[];
    Block0=[];
    for i=1:M,
        index=[index ((i-1)*M*p+i:M:i*M*p)];
        mone=eye(M);
        mone(i,i)=0;
        mzero=eye(M)-mone;
        Block1=blkdiag(Block1,kron(eye(p),mone));
        Block0=blkdiag(Block0,kron(eye(p),mzero));
    end;
elseif mode==5
    Q1 = upd;  % a4 of thesis
elseif mode==6
    Q1 = eye(L)*UC^2;
elseif mode==7
    Q1 = eye(L)*UC;
end


curval = 1;
for n = 2:LEN
    
    if verb==2 && ~mod(n,100)
        waitbar(n/LEN,h,...
        sprintf('fitting VAR[%d] model [mode=%s] (%d/%d) ...', ...
        p,'Kalman',n,LEN)); 
    end

    
    if(n<=p)
        Yr=[y(n-1:-1:1,:)' zeros(M,p-n+1)];	%vector of past observations
        Yr=Yr(:)';
    else
        Yr=y(n-1:-1:n-p,:)';				%vector of past observations
        Yr=Yr(:)';
    end
    
    %Update of measurement matrix
    H=kron(eye(M),Yr);
    
    
    %calculate prediction error
    ye(n,:)=(H*x)';
    err=y(n,:)-ye(n,:);
    
    if ~any(isnan(err(:))),
        %update of Q2 (measurement noise covariance matrix, V)) using the prediction error of the previous step
        Q2=(1-UC)*Q2+UC*(err'*err);
        
        
        KpH=Kp*H';
        HKp=H*Kp;
        
        %Kalman gain
        G=KpH/(H*KpH+Q2);
        
        %calculation of the a-posteriori state error covariance matrix
        %K=Kp-G*KpH'; Althouh PK is supposed to be symmetric, this operation makes the filter unstable
        K=Kp-G*HKp;
        
        %mode==0 no update of Q1 (process noise covariance matrix, W)
        %update of Q1 using the predicted state error cov matrix
        if (mode==1)
            Q1=diag(diag(K)).*UC;
        elseif(mode==2)  % similar to mode a2 from thesis
            Q1=upd*trace(K);
        elseif(mode==3)
            Q1=diag(sum((Block*diag(diag(K)))'))/(p*M)*UC;
        elseif(mode==4)
            avg=trace(K(index,index))/(p*M)*UC;
            Q1=Block1*UC+Block0*avg;
        end
        
        %a-priori state error covariance matrix for the next time step
        Kp=K+Q1;
        
        %current estimation of state x
        x=x+G*(err)';
        
        if doConstraints
            KD = K*Constr_D';
            
            % project the solution onto the constraint surface
            x = x - (KD/(Constr_D*KD))*(Constr_D*x - Constr_d);
        end
        
    end; % isnan(err)
    
    if ~mod(n-1,downsampleFactor)
        % store the current state
        curval = curval + 1;
        
        
        if 0; doConstraints;
            
            KD = K*Constr_D';
            
            % project the solution onto the constraint surface
            xout(:,curval) = x - (KD/(Constr_D*KD))*(Constr_D*x - Constr_d);
        else
            
            xout(:,curval) = x;
        end

        if nargout>3,
            Q2out(:,:,curval)=Q2;
        end;
        
        if nargout>4,
            Q1out(:,:,curval)=Q1;
        end;
        
        if nargout>5
            Kout(:,:,curval) = K;
        end
    end
end;

if nargout > 1
    e = y - ye;
end

if nargout > 2
    Kalman.ye = ye;
    Kalman.F  = F;
    Kalman.Q1 = Q1;
    Kalman.Kp = Kp;
    Kalman.Q2 = Q2;
    Kalman.x = x;
    Kalman.H = H;
    Kalman.G = G;
end

xout = xout';

if verb==2, close(h); end

